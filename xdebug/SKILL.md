---
name: xdebug
description: 命令行调试工作流。用户输入 /xdebug 时激活。自动构建运行 App、捕获日志、引导复现、定位修复，全程选项驱动。
allowed-tools: ["Bash", "Read", "Edit", "Write", "Grep", "Glob", "AskUserQuestion", "Task"]
argument-hint: "[bug描述 | #issue编号 | reinit]"
disable-model-invocation: true
---

# 命令行调试工作流

## 目录

- [阶段 0：探测项目](#阶段-0探测项目)
- [阶段 1：确认问题](#阶段-1确认问题)
- [阶段 2：加日志 + 构建 + 运行](#阶段-2加日志--构建--运行)
- [阶段 3：引导用户操作](#阶段-3引导用户操作)
- [阶段 4：分析日志](#阶段-4分析日志)
- [阶段 5：修复 + 验证](#阶段-5修复--验证)
- [阶段 6：收尾](#阶段-6收尾)
- [关键原则](#关键原则)

## 启动方式

- 用户输入 `/xdebug` 时激活

### 参数处理（`$ARGUMENTS`）

- **空** → 正常走阶段 1 询问
- **`reinit`** → 删除 SKILL-STATE.md 中 `## xdebug` 段（`python3 .claude/skills/xbase/skill-state.py delete xdebug`）+ 重新执行阶段 0
- **以 `#` 开头**（如 `#003`）→ 从 ISSUES.md 取对应条目作为问题描述，用 `issues.py status` 设为 🟡，跳过阶段 1 直接进入阶段 2
- **其他文本** → 作为 bug 描述，跳过阶段 1 直接进入阶段 2

## 流程

### 预加载状态
!`python3 .claude/skills/xbase/skill-state.py check xdebug 2>/dev/null`
!`python3 .claude/skills/xbase/skill-state.py read 2>/dev/null`

### 阶段 0：探测项目

> **快速跳过**：查看上方预加载结果。
> - 输出 `initialized` → 已有状态信息可用 → **跳过整个阶段 0**
> - 输出 `not_found` → 执行下方完整探测流程

1. **项目探测**：按 xbase skill 中的标准流程执行（扫描项目、读 CLAUDE.md、确定项目关键信息）
2. **验证并补齐调试基础设施**：按 `references/infra-setup.md` 中的流程检查四项能力（构建、后台启动、日志捕获、停止），缺失的自动创建。后续阶段的"构建""启动""读日志""停止"均通过此基础设施执行，不再各自拼命令。

3. 检测调试日志文件（DEBUG_LOG.md），判断状态：
   - **不存在** → 在项目文档目录创建（格式见 `references/debug-log-format.md`）
   - **存在但格式不符** → 用 AskUserQuestion 询问是否迁移（保留原始内容，套用新格式）
   - **存在且格式正确** → 跳过，无需操作

4. **写入 SKILL-STATE.md**：按 xbase 规范，用脚本写入：
   ```bash
   python3 .claude/skills/xbase/skill-state.py write-info 类型 "<类型>" 构建命令 "<命令>" 运行脚本 "<脚本>" 日志位置 "<路径>"
   python3 .claude/skills/xbase/skill-state.py write xdebug debug_log "<DEBUG_LOG.md 路径>"
   ```

### 阶段 1：确认问题

用 AskUserQuestion，一步到位。**同时后台启动构建**（用户思考的时间不浪费）：

```
问题：这次调试什么？
选项：
- 从 ISSUES.md 选取（→ 用 issues.py list 展示 🔴 项，用户选一个后 issues.py status 设为 🟡）
- 探索性测试（先跑起来看日志）
- 继续上次调试
- Other → 用户直接输入 Bug 描述
```

### 阶段 2：加日志 + 构建 + 运行

**此阶段不问用户，全部自动完成：**

1. 判断现有日志是否足够覆盖问题区域（先查 LOG-COVERAGE.md，再读相关代码确认）
   - 覆盖足够 → 直接构建运行
   - 覆盖不足 → 启动子 agent（Task 工具），在 prompt 参数中直接传入目标文件和问题描述，让它读取 `.claude/skills/xlog/SKILL.md` 并按 `/xlog` 流程给目标区域补日志。子 agent 完成后主流程继续
2. 执行构建命令（从阶段 0 推导）
3. 编译失败 → 自己修复后重试，不问用户
4. 停止旧进程，后台启动项目，日志输出到阶段 0 确定的位置

### 阶段 3：引导用户操作

用 AskUserQuestion，**根据具体 Bug 给出操作步骤**，不要泛泛说"请操作"。

示例：如果 Bug 是"拖拽元素时位置偏移"，则：

```
问题：App 已启动，请按以下步骤操作：
  1. 创建一个元素
  2. 拖动它到右侧
  3. 观察位置是否偏移
  操作完选择：
选项：
- 操作完了，看日志
- 问题没复现
- App 崩溃了 / 没启动
```

### 阶段 4：分析日志

1. 读取日志：通过运行脚本的 `logs` 命令读取，**先用级别/模块过滤缩小范围**，再按需关键词搜索。不要一次读全量日志
2. 用 AskUserQuestion 展示分析结论（**App 保持运行，不要停**）：

```
问题：[简短分析摘要]。下一步？
选项：
- 已定位，修复代码
- 日志不够，加日志再来一轮（→ 回到阶段 2）
- 放弃，记录到 TODO
- Other → 用户补充信息
```

### 阶段 5：修复 + 验证

1. 停止项目（改代码前才停）
2. 修改代码修复 Bug
3. 删除临时诊断日志（保留有长期价值的日志）
4. 重新构建 + 后台启动项目（同阶段 2）
5. 用 AskUserQuestion，**同样给出具体验证步骤**：

```
问题：已修复并重启，请验证：
  [具体验证操作步骤]
选项：
- 修好了
- 没修好，继续调（→ 回到阶段 2）
- Other → 修好了但发现新问题，请描述
```

### 阶段 6：收尾

**仅在确认修好后执行，不问用户：**

1. 停止项目
2. 在 DEBUG_LOG.md 追加本次 Bug 修复记录（格式见 `references/debug-log-format.md`）
3. 如涉及技术决策且项目有决策记录文档，更新记录
4. 如果本次修复来自 ISSUES.md：
   - 用 `issues.py status` 将状态从 🟡 改为 🟢
   - 用 Edit 工具在对应条目下写入修复说明
5. 用 AskUserQuestion：

```
问题：修复完成。下一步？
选项：
- 继续修下一个（→ 如果 ISSUES.md 还有 🔴 条目，回阶段 1）
- 结束
- Other → 用户描述新问题
```

选择"继续修下一个"且 ISSUES.md 有 🔴 条目 → 回到阶段 1。
用户描述了新问题 → 以新问题回到阶段 1。

---

## 关键原则

- **不硬编码** — 构建命令、路径、日志系统均从项目动态推导
- **选项优先于打字** — 能用选项就不让用户打字，Other 兜底自由输入
- **操作步骤要具体** — 根据 Bug 给出 1-2-3 步骤，不要说"请操作复现"
- **每轮只问一个问题** — 不堆叠多个问题
- **先加日志后改代码** — 禁止盲猜
- **加日志委派子 agent** — 子 agent 读 `/xlog` SKILL.md 执行，主流程不中断
- **App 不要提前停** — 分析日志时保持运行，确认要改代码了再停
- **编译问题自己解决** — 编译失败不问用户
- **没修好不更新文档** — 只在确认修复后更新
